<?php

namespace ramazancetinkaya;

use RuntimeException;

/**
 * Class EncryptionDecryption
 *
 * This class provides advanced AES-256-GCM encryption and decryption functionality.
 * It supports an optional URL-safe mode for encoding and decoding data.
 *
 * PHP version 8
 *
 * @category  Security
 * @package   EncryptionDecryption
 * @author    Ramazan Çetinkaya
 * @copyright 2025 Ramazan Çetinkaya
 * @license   MIT License <https://opensource.org/licenses/MIT>
 * @version   1.0.0
 * @link      https://github.com/ramazancetinkaya/php-encryption-decryption
 */
class EncryptionDecryption
{
    /**
     * The cipher method to be used for AES-256-GCM.
     *
     * @var string
     */
    private const CIPHER = 'aes-256-gcm';

    /**
     * The user-defined key for encryption and decryption (32 bytes recommended).
     *
     * @var string
     */
    private string $key;

    /**
     * Whether to use URL-safe encoding/decoding.
     *
     * @var bool
     */
    private bool $useUrlSafe;

    /**
     * Constructor for the EncryptionDecryption class.
     *
     * @param string $key         The encryption key (32 bytes recommended for AES-256).
     * @param bool   $useUrlSafe  If true, encoding/decoding will be URL-safe.
     *
     * @throws RuntimeException If the key is invalid or empty.
     */
    public function __construct(string $key, bool $useUrlSafe = false)
    {
        if (empty($key)) {
            throw new RuntimeException('Encryption key cannot be empty.');
        }

        $this->key = $key;
        $this->useUrlSafe = $useUrlSafe;
    }

    /**
     * Generates a random encryption key of given length in bytes.
     * Defaults to 32 bytes for AES-256.
     *
     * @param int $length The length of the key in bytes.
     *
     * @return string Returns the generated key in raw binary format.
     *
     * @throws RuntimeException If random_bytes fails.
     */
    public function generateKey(int $length = 32): string
    {
        try {
            return random_bytes($length);
        } catch (\Exception $e) {
            throw new RuntimeException('Failed to generate a random key: ' . $e->getMessage());
        }
    }

    /**
     * Generates a random Initialization Vector (IV) for AES-256-GCM.
     *
     * @return string Returns the IV in raw binary format.
     *
     * @throws RuntimeException If openssl_cipher_iv_length or random_bytes fails.
     */
    public function generateIv(): string
    {
        $ivLength = openssl_cipher_iv_length(self::CIPHER);
        if ($ivLength === false) {
            throw new RuntimeException('Unable to determine IV length for cipher: ' . self::CIPHER);
        }

        try {
            return random_bytes($ivLength);
        } catch (\Exception $e) {
            throw new RuntimeException('Failed to generate IV: ' . $e->getMessage());
        }
    }

    /**
     * Encrypts the given plaintext using AES-256-GCM.
     *
     * @param string      $plaintext The plaintext data to encrypt.
     * @param string|null $aad       (Optional) Additional authentication data.
     *
     * @return string Returns the encrypted data, encoded (base64 or URL-safe base64).
     *
     * @throws RuntimeException If encryption fails or data cannot be encoded.
     */
    public function encryptData(string $plaintext, ?string $aad = null): string
    {
        $iv = $this->generateIv();

        // Tag will be generated by openssl_encrypt in GCM mode
        $tag = '';
        $tagLength = 16; // 16 bytes is recommended for GCM tag length

        $ciphertext = openssl_encrypt(
            $plaintext,
            self::CIPHER,
            $this->key,
            OPENSSL_RAW_DATA,
            $iv,
            $tag,
            $aad ?? '',
            $tagLength
        );

        if ($ciphertext === false) {
            throw new RuntimeException('Encryption failed: Unable to encrypt data.');
        }

        // Prepare data for serialization
        $encryptedData = [
            'iv'         => bin2hex($iv),
            'tag'        => bin2hex($tag),
            'ciphertext' => bin2hex($ciphertext),
        ];

        // JSON encode the data
        $jsonData = json_encode($encryptedData);
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new RuntimeException('Encryption failed: Unable to encode JSON.');
        }

        // Base64 encode (optionally URL-safe)
        $encodedData = base64_encode($jsonData);
        if ($this->useUrlSafe) {
            $encodedData = $this->toUrlSafe($encodedData);
        }

        return $encodedData;
    }

    /**
     * Decrypts the given encrypted data using AES-256-GCM.
     *
     * @param string      $encryptedData The encrypted data (base64 or URL-safe base64).
     * @param string|null $aad           (Optional) Additional authentication data.
     *
     * @return string Returns the decrypted plaintext data.
     *
     * @throws RuntimeException If decryption fails or data cannot be decoded.
     */
    public function decryptData(string $encryptedData, ?string $aad = null): string
    {
        // Reverse URL-safe if needed
        if ($this->useUrlSafe) {
            $encryptedData = $this->fromUrlSafe($encryptedData);
        }

        // Decode from base64
        $jsonData = base64_decode($encryptedData, true);
        if ($jsonData === false) {
            throw new RuntimeException('Decryption failed: Unable to base64 decode data.');
        }

        // JSON decode to retrieve IV, tag, and ciphertext
        $decodedData = json_decode($jsonData, true);
        if (json_last_error() !== JSON_ERROR_NONE || !is_array($decodedData)) {
            throw new RuntimeException('Decryption failed: Invalid JSON structure.');
        }

        // Validate required fields
        if (
            !isset($decodedData['iv'], $decodedData['tag'], $decodedData['ciphertext']) ||
            !is_string($decodedData['iv']) ||
            !is_string($decodedData['tag']) ||
            !is_string($decodedData['ciphertext'])
        ) {
            throw new RuntimeException('Decryption failed: Invalid encrypted data format.');
        }

        // Convert hex to binary
        $iv         = hex2bin($decodedData['iv']);
        $tag        = hex2bin($decodedData['tag']);
        $ciphertext = hex2bin($decodedData['ciphertext']);

        if ($iv === false || $tag === false || $ciphertext === false) {
            throw new RuntimeException('Decryption failed: Unable to convert hex to binary.');
        }

        // Perform decryption
        $plaintext = openssl_decrypt(
            $ciphertext,
            self::CIPHER,
            $this->key,
            OPENSSL_RAW_DATA,
            $iv,
            $tag,
            $aad ?? ''
        );

        if ($plaintext === false) {
            throw new RuntimeException('Decryption failed: Unable to decrypt data.');
        }

        return $plaintext;
    }

    /**
     * Converts a standard Base64 string to a URL-safe Base64 variant.
     *
     * @param string $data The standard base64-encoded string.
     *
     * @return string Returns the URL-safe base64 variant.
     */
    private function toUrlSafe(string $data): string
    {
        // Replace + with -, / with _, and trim =
        return rtrim(strtr($data, '+/', '-_'), '=');
    }

    /**
     * Converts a URL-safe Base64 string back to the standard Base64 variant.
     *
     * @param string $data The URL-safe base64-encoded string.
     *
     * @return string Returns the standard base64 variant.
     */
    private function fromUrlSafe(string $data): string
    {
        // Replace - with +, _ with /
        $data = strtr($data, '-_', '+/');
        // Calculate missing padding
        $padding = 4 - (strlen($data) % 4);
        if ($padding !== 4) {
            $data .= str_repeat('=', $padding);
        }

        return $data;
    }
}
